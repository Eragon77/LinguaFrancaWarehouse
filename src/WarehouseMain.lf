target Python {
    files: [
        "python/warehouse_platform.py",
        "python/tray.py",
        "python/slot.py",
        "python/warehouse.py",
        "python/command_reader.py",
        "python/warehouse_controller.py",
    ], 
};

preamble{=
    from warehouse_platform import Platform
    from tray import Tray
    from slot import Slot
    from warehouse import Warehouse
    from command_reader import load_commands
    from warehouse_controller import WarehouseController

    import logging

    logging.basicConfig(
        level=logging.INFO,
        filename="logfile.log",
        encoding="utf-8",
        filemode="w",
        format="{asctime} - {levelname} - {message}",
        style="{",
        datefmt="%Y-%m-%d %H:%M:%S",
        )
=}

main reactor WarehouseMain {
    state wh
    state wh_ctrl
    state command_list
    
    logical action execute_next_command;
    logical action execute_step;
    logical action read_commands;

    reaction(startup)->read_commands{=
        self.wh=Warehouse()
        self.wh_ctrl=WarehouseController(self.wh)
        self.command_list=load_commands("commands.yaml")

        logging.info("[*] Warehouse system initialized.")
        read_commands.schedule(0)
    =}

    reaction(read_commands) -> execute_next_command, read_commands{=
        if len(self.command_list) > 0:
            cmd = self.command_list.pop()
            self.wh_ctrl.set_busy()
            print(f"Processing command: {cmd}")
            execute_next_command.schedule(0, cmd)
        else:
            logging.info(f"[*] All commands executed.")
            lf.request_stop()
    =}

    reaction(execute_next_command) -> execute_step, read_commands {=
        cmd = execute_next_command.value
        success = False

        # Handle ENQUEUE command (requires tray_id)
        if cmd["action"] == "enqueue_tray":
            if "tray_id" in cmd:
                success = self.wh_ctrl.build_enqueue_sequence(str(cmd["tray_id"]))
            else:
                logging.error("[*] Enqueue failed: 'tray_id' missing in command.")

        # Handle SEND_BACK command (moves from Bay to Storage)
        elif cmd["action"] == "send_back_tray":
            success = self.wh_ctrl.build_send_back_sequence()
        
        # Handle EXTRACT command (moves first tray from Queue to Bay)
        elif cmd["action"] == "extract_tray":
            success = self.wh_ctrl.build_extract_sequence()

        else:
            logging.warning(f"[*] Unknown or unsupported command action: {cmd['action']}")

        # --- EXECUTION START ---
        if success:
            # Retrieve the first step (time=0.0 for the first logical step)
            time, method, args, msg = self.wh_ctrl.get_next_step()

            if time is not None:
                logging.info(f"[*] Executing step: {msg}")
                execute_step.schedule(0, (method, args, msg))
            else:
                # Sequence empty
                self.wh_ctrl.set_idle()
                read_commands.schedule(0)
        else:
            logging.error(f"[*] Command execution failed for action: {cmd['action']}.")
            self.wh_ctrl.set_idle()
            read_commands.schedule(0)
    =}

    reaction(execute_step)->execute_step, read_commands{=
        # Unpack step data
        method, args, msg = execute_step.value

        # Execute function
        success = self.wh_ctrl.execute_step(method, args)
        
        # If it fails, log and stop.
        if not success:
            logging.error(f"[*] CRITICAL: Execution step failed: {msg}. Aborting sequence.")
            self.wh_ctrl.set_idle()
            lf.request_stop()
            return

        # Retrieve the next step from the sequence (time = duration of the previous step)
        time, next_func, next_args, next_msg = self.wh_ctrl.get_next_step()
        
        if time is not None:
            # Schedule the next step with the calculated delay (LF advances time)
            delay = int(time * 1000)
            execute_step.schedule(MSEC(delay), (next_func, next_args, next_msg))
        else:
            # Sequence finished
            logging.info(f"[*] Sequence complete.")
            self.wh_ctrl.set_idle()
            read_commands.schedule(SEC(0))
    =}
}