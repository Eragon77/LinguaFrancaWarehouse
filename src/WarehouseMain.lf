target Python {
    files: [
        "python/warehouse_platform.py",
        "python/tray.py",
        "python/slot.py",
        "python/warehouse.py",
        "python/command_reader.py"
    ], 
};

preamble{=
    from warehouse_platform import Platform
    from tray import Tray
    from slot import Slot
    from warehouse import Warehouse
    from command_reader import load_commands

    import logging

    logging.basicConfig(
        level=logging.INFO,
        filename="logfile.log",
        encoding="utf-8",
        filemode="w",
        format="{asctime} - {levelname} - {message}",
        style="{",
        datefmt="%Y-%m-%d %H:%M:%S",
        )

    def get_y_move_time(platform, target_y):
            d = abs(target_y - platform.curr_y)
            speed = platform.speed_y
            return d / speed

    def get_x_move_time(platform, target_x):
            d = abs(target_x - platform.curr_x)
            speed = platform.extract_speed
            return d / speed 
=}


main reactor WarehouseMain {

    state wh
    state command_list

    
    logical action execute_next_command;


    #PICKUP TRAY
    logical action move_to_pickup;
    logical action extract_to_pickup;
    logical action perform_pickup;
    logical action retract_after_pickup;

    #PLACE TRAY
    logical action move_to_place;
    logical action extract_to_place;
    logical action perform_place;
    logical action retract_after_place;

    logical action emergency_retract;

    timer read_commands_timer(0, 3 secs)


    reaction(startup){=
        self.wh=Warehouse()
        self.command_list=load_commands("commands.yaml")

        logging.info("[*] Warehouse system initialized.")
    =}

   reaction(read_commands_timer) -> execute_next_command{=
        # Check if the warehouse is already processing another command
        if not self.wh.is_ready():
            return

        if len(self.command_list) > 0:
            # Dequeue the next command
            cmd = self.command_list.pop()
            
            # Set the lock to prevent new commands from starting
            self.wh.set_busy()
            
            # Schedule the command for execution
            execute_next_command.schedule(0, cmd)
        else:
            # No commands left in the queue
            logging.info("[*] No more commands to execute.")
            lf.request_stop() #IS IDLING BETTER?
    =}

    reaction(execute_next_command) -> move_to_pickup, move_to_place {=
        
        cmd = execute_next_command.value
        #TODO:PRINT?

        if cmd["action"] == "move":
            
            slot_from = self.wh.get_slot_by_id(cmd["from"])
            slot_to = self.wh.get_slot_by_id(cmd["to"])

            if slot_from and slot_to:
                # Chain started, DO NOT set idle
                move_to_pickup.schedule(0, (slot_from, slot_to))
            else:
                # Chain failed, DO set idle
                logging.warning(f"[!] Invalid slot IDs in command: {cmd}")
                self.wh.set_idle()
            
        elif cmd["action"] == "swap":
            slot_a = self.wh.get_slot_by_id(cmd["from"])
            slot_b = self.wh.get_slot_by_id(cmd["to"])
            
            slot_temp = self.wh.find_empty_storage_slot()

            if not (slot_a and slot_b and slot_temp):
                logging.warning(f"[!] Invalid slot IDs in command: {cmd}")
                if not slot_temp: 
                    logging.warning(f"[!] No empty storage slot available for swap operation.")
                self.wh.set_idle() # Chain failed, DO set idle
                return
                
            logging.info(f"[*] Swapping {slot_a.position_id} with {slot_b.position_id} using temporary slot {slot_temp.position_id}.")
            cmd_1 = {"action":"move", "from": slot_a.position_id, "to": slot_temp.position_id}
            cmd_2 = {"action":"move", "from": slot_b.position_id, "to": slot_a.position_id}
            cmd_3 = {"action":"move", "from": slot_temp.position_id, "to": slot_b.position_id}

            self.command_list.append(cmd_3)
            self.command_list.append(cmd_2)
            self.command_list.append(cmd_1)

            # command is finished, DO set idle
            self.wh.set_idle()

        elif cmd["action"]=="move_from_platform":
            slot_to = self.wh.get_slot_by_id(cmd["to"])
            
            if slot_to:
                logging.info(f"[*] ROLLBACK: moving tray from platform to {slot_to.position_id}.")
                # Chain started, DO NOT set idle
                move_to_place.schedule(0, (None, slot_to))
            else:
                logging.error(f"[!] ERROR: Rollback slot {cmd['to']} not found.")
                lf.request_stop()
                
        else:
            # Unknown command, DO set idle
            logging.warning(f"[!] Unknown action: {cmd.get('action')}")
            self.wh.set_idle()
    =}

    reaction(move_to_pickup) -> extract_to_pickup {=
        slot_from = move_to_pickup.value[0]
        slot_to = move_to_pickup.value[1]

        platform = self.wh.platform 
        timeY = get_y_move_time(platform, slot_from.y)
        timeY_ms = int(timeY * 1000)
        
        logging.info(f"[Y] Moving to {slot_from.position_id}. Time: {timeY} sec")
        
        extract_to_pickup.schedule(MSEC(timeY_ms), (slot_from,slot_to))
    =}

    reaction(extract_to_pickup) -> perform_pickup {=
        slot_from = extract_to_pickup.value[0]
        slot_to = extract_to_pickup.value[1]
        
        self.wh.platform.update_y_position(slot_from.y)
        logging.info(f"[Y] Arrived at {slot_from.position_id}.")

        platform=self.wh.platform
        timeX = get_x_move_time(platform, slot_from.x)
        timeX_ms= int(timeX * 1000)
        
        logging.info(f"[X] Extracting from {slot_from.position_id}. Time: {timeX} sec")
        
        perform_pickup.schedule(MSEC(timeX_ms), (slot_from, slot_to))
    =}

    reaction(perform_pickup) -> retract_after_pickup {=
        slot_from = perform_pickup.value[0]
        slot_to = perform_pickup.value[1]

        success = self.wh.platform.pick_up_from(slot_from)

        
        if not success:
            logging.error(f"[!] ERROR: Pickup failed. Idling warehouse.")
            self.wh.set_idle()
            return
            
        logging.info(f"[*] Pickup from {slot_from.position_id}: {success}")
        platform = self.wh.platform
        timeX = get_x_move_time(platform, slot_from.x)
        timeX_ms = int(timeX * 1000)
        logging.info(f"[X] Retracting extractor. Time: {timeX} sec")
        retract_after_pickup.schedule(MSEC(timeX_ms), (slot_from, slot_to))
    =}

    reaction(retract_after_pickup) -> move_to_place {=
        slot_from = retract_after_pickup.value[0]
        slot_to = retract_after_pickup.value[1]
        
        self.wh.platform.update_x_position(0)
        logging.info(f"[*] Extractor retracted.")
        
        platform = self.wh.platform
        timeY = get_y_move_time(platform, slot_to.y) 
        timeY_ms = int(timeY * 1000)
        
        logging.info(f"[Y] Moving to {slot_to.position_id}. Time: {timeY} sec")

        move_to_place.schedule(MSEC(timeY_ms), (slot_from, slot_to))
    =}

    reaction(move_to_place) -> extract_to_place {=
        slot_from = move_to_place.value[0]
        slot_to = move_to_place.value[1]

        self.wh.platform.update_y_position(slot_to.y)

        logging.info(f"[Y] Arrived at {slot_to.position_id}.")
        platform = self.wh.platform
        timeX = get_x_move_time(platform, slot_to.x)
        timeX_ms = int(timeX * 1000)
        
        logging.info(f"[X] Extracting to {slot_to.position_id}. Time: {timeX} sec")
        
        extract_to_place.schedule(MSEC(timeX_ms), (slot_from, slot_to))
    =}

    reaction(extract_to_place) -> perform_place {=
        slot_from = extract_to_place.value[0]
        slot_to = extract_to_place.value[1]
        
        self.wh.platform.update_x_position(slot_to.x)
        logging.info(f"[X] Arrived at {slot_to.position_id}. Scheduling instant place.")

        perform_place.schedule(0, (slot_from, slot_to))
    =}

    reaction(perform_place) -> retract_after_place,emergency_retract {=
        slot_from = perform_place.value[0]
        slot_to = perform_place.value[1]
        platform = self.wh.platform

        success = self.wh.platform.place_into(slot_to)

        
        if not success:
            logging.error(f"[!] ERROR: Place failed..")
            logging.info(f"[*] ROLLBACK started.")

            timeX = get_x_move_time(platform, slot_to.x)
            timeX_ms = int(timeX * 1000)

            emergency_retract.schedule(MSEC(timeX_ms), slot_from)
            return
            
        logging.info(f"[*] Place into {slot_to.position_id}: {success}")
        

        timeX = get_x_move_time(platform, slot_to.x)
        timeX_ms = int(timeX * 1000)
        
        logging.info(f"[X] Retracting extractor. Time: {timeX} sec")

        retract_after_place.schedule(MSEC(timeX_ms), (slot_from, slot_to))
    =}


    reaction(retract_after_place) {=
        slot_from = retract_after_place.value[0]
        slot_to = retract_after_place.value[1]
        
        self.wh.platform.update_x_position(0)

        if slot_from:
            # Log for a "move"
            logging.info(f"[*] Extractor retracted. Move from {slot_from.position_id} to {slot_to.position_id} complete.")
        else:
            # Log for a "rollback"
            logging.info(f"[*] Extractor retracted. Rollback to {slot_to.position_id} complete.")

        self.wh.set_idle()
    =}

    reaction(emergency_retract) {=
        slot_from = emergency_retract.value
        
        self.wh.platform.update_x_position(0)
        logging.warning(f"[*] Emergency retract complete. Platform is at x=0.")


        cmd_rollback={"action":"move_from_platform","to":slot_from.position_id}
        self.command_list.append(cmd_rollback)

        self.wh.set_idle()
    =}

}